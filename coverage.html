
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>admin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/plakak13/assessment-tax/admin/handler.go (100.0%)</option>
				
				<option value="file1">github.com/plakak13/assessment-tax/postgres/admin.go (100.0%)</option>
				
				<option value="file2">github.com/plakak13/assessment-tax/postgres/postgres.go (0.0%)</option>
				
				<option value="file3">github.com/plakak13/assessment-tax/postgres/tax.go (97.4%)</option>
				
				<option value="file4">github.com/plakak13/assessment-tax/tax/handler.go (93.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package admin

import (
        "database/sql"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/plakak13/assessment-tax/helper"
        "github.com/plakak13/assessment-tax/postgres"
        "github.com/plakak13/assessment-tax/tax"
)

type Handler struct {
        store Storer
}

type Storer interface {
        UpdateTaxDeduction(s postgres.SettingTaxDeduction) (sql.Result, error)
        TaxDeductionByType(allowanceTypes []string) ([]tax.TaxDeduction, error)
}

func New(db Storer) *Handler <span class="cov8" title="1">{
        return &amp;Handler{store: db}
}</span>

func (h *Handler) AdminHandler(c echo.Context) error <span class="cov8" title="1">{
        payload := new(Setting)
        param := c.Param("type")

        if err := c.Bind(payload); err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, "Invalid JSON", http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">err := c.Validate(payload)

        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">tRows, err := h.store.TaxDeductionByType([]string{param})
        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>

        <span class="cov8" title="1">if tRows[0].AdminOverrideMax &lt; payload.Amount </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("ยอดที่กำหนดมีค่าเกินกว่า (%.1f) ที่สามารถกำหนดได้", tRows[0].AdminOverrideMax)
                return helper.FailedHandler(c, msg, http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">if tRows[0].MinAmount &gt; payload.Amount </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("กรุณากำหนดมีค่าเกินกว่า (%.1f)", tRows[0].MinAmount)
                return helper.FailedHandler(c, msg, http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">s := postgres.SettingTaxDeduction{
                ID:     tRows[0].ID,
                Amount: payload.Amount,
        }

        row, err := h.store.UpdateTaxDeduction(s)
        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>
        <span class="cov8" title="1">_, err = row.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>

        <span class="cov8" title="1">return helper.SuccessHandler(c, SettingResponse{PersonalDeduction: payload.Amount})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package postgres

import "database/sql"

type SettingTaxDeduction struct {
        ID     int
        Amount float64
}

type UpdateTaxDeductionResponse struct {
        RowEffectID  int
        LastInsertId int
}

func (p *Postgres) UpdateTaxDeduction(s SettingTaxDeduction) (sql.Result, error) <span class="cov8" title="1">{

        query := `UPDATE tax_deduction SET max_deduction_amount = $1 WHERE id = $2 `

        row, err := p.Db.Exec(query, s.Amount, s.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return row, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package postgres

import (
        "database/sql"
        "log"
        "os"

        "github.com/joho/godotenv"
        _ "github.com/lib/pq"
)

type Database interface {
        QueryRow(query string, args ...interface{}) *sql.Row
}

type Postgres struct {
        Db *sql.DB
}

func New() (*Postgres, error) <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">databaseUrl := os.Getenv("DATABASE_URL")

        db, err := sql.Open("postgres", databaseUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return &amp;Postgres{Db: db}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package postgres

import (
        "fmt"
        "time"

        "github.com/plakak13/assessment-tax/tax"
)

type TaxDeduction struct {
        ID                 int        `postgres:"id"`
        MaxDeductionAmount float64    `postgres:"max_deduction_amount"`
        DefaultAmount      float64    `postgres:"default_amount"`
        AdminOverrideMax   float64    `postgres:"admin_override_max"`
        MinAmount          float64    `postgres:"min_amount"`
        TaxAllowanceType   string     `postgres:"tax_allowance_type"`
        CreatedAt          time.Time  `postgres:"created_at"`
        UpdatedAt          *time.Time `postgres:"updated_at"`
}

type TaxRate struct {
        ID               int        `postgres:"id"`
        LowerBoundIncome float64    `postgres:"lower_bound_income"`
        TaxRate          float64    `postgres:"tax_rate"`
        CreatedAt        time.Time  `postgres:"created_at"`
        UpdatedAt        *time.Time `postgres:"updated_at"`
}

func (p *Postgres) TaxDeductionByType(allowanceTypes []string) ([]tax.TaxDeduction, error) <span class="cov8" title="1">{

        if len(allowanceTypes) == 0 </span><span class="cov8" title="1">{
                return []tax.TaxDeduction{}, fmt.Errorf("please sent allowance type as least 1")
        }</span>

        <span class="cov8" title="1">var td []tax.TaxDeduction
        argsTax := make([]any, len(allowanceTypes))

        query := "SELECT id, max_deduction_amount, default_amount, admin_override_max, min_amount, tax_allowance_type FROM tax_deduction WHERE tax_allowance_type IN ("

        for i, att := range allowanceTypes </span><span class="cov8" title="1">{
                query += fmt.Sprintf("$%d", i+1)
                argsTax[i] = att
                if i &lt; len(allowanceTypes)-1 </span><span class="cov8" title="1">{
                        query += ", "
                }</span>
        }
        <span class="cov8" title="1">query += ")"

        stmt, err := p.Db.Prepare(query)
        if err != nil </span><span class="cov8" title="1">{
                return td, err
        }</span>

        <span class="cov8" title="1">rows, err := stmt.Query(argsTax...)
        if err != nil </span><span class="cov8" title="1">{
                return td, err
        }</span>

        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var t tax.TaxDeduction
                err = rows.Scan(
                        &amp;t.ID,
                        &amp;t.MaxDeductionAmount,
                        &amp;t.DefaultAmount,
                        &amp;t.AdminOverrideMax,
                        &amp;t.MinAmount,
                        &amp;t.TaxAllowanceType,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return td, err
                }</span>
                <span class="cov8" title="1">td = append(td, tax.TaxDeduction{
                        ID:                 t.ID,
                        MaxDeductionAmount: t.MaxDeductionAmount,
                        DefaultAmount:      t.DefaultAmount,
                        AdminOverrideMax:   t.AdminOverrideMax,
                        MinAmount:          t.MinAmount,
                        TaxAllowanceType:   t.TaxAllowanceType,
                })</span>
        }

        <span class="cov8" title="1">return td, nil</span>
}

func (p *Postgres) TaxRates() ([]tax.TaxRate, error) <span class="cov8" title="1">{
        query := `SELECT id, lower_bound_income, tax_rate FROM tax_rate`
        rows, err := p.Db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer rows.Close()
        var tr []tax.TaxRate

        for rows.Next() </span><span class="cov8" title="1">{
                var t tax.TaxRate
                err = rows.Scan(&amp;t.ID, &amp;t.LowerBoundIncome, &amp;t.TaxRate)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tr = append(tr, tax.TaxRate{
                        ID:               t.ID,
                        LowerBoundIncome: t.LowerBoundIncome,
                        TaxRate:          t.TaxRate,
                })</span>
        }
        <span class="cov8" title="1">return tr, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package tax

import (
        "encoding/csv"
        "errors"
        "fmt"
        "io"
        "math"
        "mime/multipart"
        "net/http"
        "slices"
        "strconv"
        "strings"

        "github.com/labstack/echo/v4"
        "github.com/plakak13/assessment-tax/helper"
        "golang.org/x/text/language"
        "golang.org/x/text/message"
        "golang.org/x/text/number"
)

type Handler struct {
        store Storer
}

type Storer interface {
        TaxRates() ([]TaxRate, error)
        TaxDeductionByType(allowanceTypes []string) ([]TaxDeduction, error)
}

func New(db Storer) *Handler <span class="cov8" title="1">{
        return &amp;Handler{store: db}
}</span>

func (h *Handler) CalculationHandler(c echo.Context) error <span class="cov8" title="1">{

        tc := new(TaxCalculation)

        err := c.Bind(tc)
        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
        }</span>
        <span class="cov8" title="1">allowanceType := []string{}

        for _, v := range tc.Allowances </span><span class="cov8" title="1">{
                allowanceType = append(allowanceType, v.AllowanceType)
        }</span>

        <span class="cov8" title="1">allowanceType = append(allowanceType, "personal")
        tds, err := h.store.TaxDeductionByType(allowanceType)

        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>

        <span class="cov8" title="1">if err = validation(tds, *tc); err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">income := tc.TotalIncome

        maxDeduct := maxDeduct(tds, tc.Allowances)
        income -= maxDeduct

        taxRates, err := h.store.TaxRates()

        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>

        <span class="cov8" title="1">rIndex := taxRateIndex(taxRates, income)

        taxFund := calculateTaxPayable(income, tc.WithHoldingTax, taxRates[rIndex])

        taxRefund, taxFund := refundTax(taxFund)
        taxLevels := taxLevelDetails(taxRates, rIndex, taxFund)

        return helper.SuccessHandler(c, CalculationResponse{
                Tax:       math.Round(taxFund*100) / 100,
                TaxRefund: math.Round(taxRefund*100) / 100,
                TaxLevel:  taxLevels,
        })</span>
}

func (h *Handler) CalculationCSV(c echo.Context) error <span class="cov8" title="1">{

        fileUploaded, err := openFile(c)
        if err != nil </span><span class="cov0" title="0">{
                return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">recs, err := readCSVRecords(fileUploaded)
        if err != nil </span><span class="cov0" title="0">{
                return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">recs = removeBOM(recs)

        if !validateCSVHeader(recs[0]) </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, "header incorrect", http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">allowanceType := []string{"personal", "donation"}

        tds, err := h.store.TaxDeductionByType(allowanceType)
        if err != nil </span><span class="cov8" title="1">{
                return helper.FailedHandler(c, err.Error())
        }</span>
        <span class="cov8" title="1">var ttis []TaxWithTotalIncome

        for i, v := range recs </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">totalIncome, wht, amount, err := parseFloatValue(v)
                if err != nil </span><span class="cov8" title="1">{
                        return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">tc := TaxCalculation{
                        TotalIncome:    totalIncome,
                        WithHoldingTax: wht,
                        Allowances: []Allowance{
                                {
                                        AllowanceType: "donation",
                                        Amount:        amount,
                                },
                        },
                }

                if err = validation(tds, tc); err != nil </span><span class="cov0" title="0">{
                        return helper.FailedHandler(c, err.Error(), http.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">maxDeduct := maxDeduct(tds, []Allowance{
                        {
                                AllowanceType: "donation",
                                Amount:        amount,
                        },
                })

                income := totalIncome - maxDeduct

                taxRates, err := h.store.TaxRates()

                if err != nil </span><span class="cov0" title="0">{
                        return helper.FailedHandler(c, err.Error())
                }</span>

                <span class="cov8" title="1">rIndex := taxRateIndex(taxRates, income)

                taxFund := calculateTaxPayable(income, wht, taxRates[rIndex])

                ttis = append(ttis, TaxWithTotalIncome{
                        TotalIncome: totalIncome,
                        TaxAmount:   taxFund,
                })</span>
        }

        <span class="cov8" title="1">return helper.SuccessHandler(c, ttis)</span>
}

func validation(taxDeducts []TaxDeduction, t TaxCalculation) error <span class="cov8" title="1">{

        if t.WithHoldingTax &lt;= 0 || t.WithHoldingTax &gt; t.TotalIncome </span><span class="cov8" title="1">{
                return errors.New("invalid withholding tax amount")
        }</span>

        <span class="cov8" title="1">for _, v := range t.Allowances </span><span class="cov8" title="1">{
                for _, vt := range taxDeducts </span><span class="cov8" title="1">{
                        if vt.TaxAllowanceType == v.AllowanceType &amp;&amp; v.Amount &lt; vt.MinAmount </span><span class="cov8" title="1">{
                                return fmt.Errorf("amount for %s allowance is below the minimum threshold", v.AllowanceType)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func calculateTaxPayable(income float64, wht float64, rate TaxRate) float64 <span class="cov8" title="1">{

        baseTax := 150000.0
        taxPercent := (rate.TaxRate / 100)
        taxfund := ((income - baseTax) * taxPercent) - wht
        return taxfund
}</span>

func maxDeduct(tds []TaxDeduction, alls []Allowance) float64 <span class="cov8" title="1">{
        var maxDeduct float64
        for _, td := range tds </span><span class="cov8" title="1">{
                if td.TaxAllowanceType == "personal" </span><span class="cov8" title="1">{
                        maxDeduct += td.MaxDeductionAmount
                }</span>
                <span class="cov8" title="1">for _, a := range alls </span><span class="cov8" title="1">{
                        if td.TaxAllowanceType == a.AllowanceType </span><span class="cov8" title="1">{
                                if td.MaxDeductionAmount &gt;= a.Amount </span><span class="cov8" title="1">{
                                        maxDeduct += a.Amount
                                }</span> else<span class="cov8" title="1"> {
                                        maxDeduct += td.MaxDeductionAmount
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return maxDeduct</span>
}

func validateCSVHeader(h []string) bool <span class="cov8" title="1">{
        expected := []string{"totalIncome", "wht", "donation"}
        return equalSlice(expected, h)
}</span>

func equalSlice(a []string, b []string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range a </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func praseFloat(s string) (float64, error) <span class="cov8" title="1">{
        return strconv.ParseFloat(s, 64)
}</span>

func openFile(c echo.Context) (multipart.File, error) <span class="cov8" title="1">{

        file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fileUploaded, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer fileUploaded.Close()
        return fileUploaded, nil</span>
}

func removeBOM(recs [][]string) [][]string <span class="cov8" title="1">{
        if len(recs) &gt; 0 &amp;&amp; strings.HasPrefix(recs[0][0], "\ufeff") </span><span class="cov8" title="1">{
                recs[0][0] = strings.TrimPrefix(recs[0][0], "\ufeff")
        }</span>
        <span class="cov8" title="1">return recs</span>
}

func taxLevelDetails(taxRates []TaxRate, rIndex int, taxFund float64) []TaxLevelInfo <span class="cov8" title="1">{
        var taxLevels []TaxLevelInfo
        p := message.NewPrinter(language.English)
        for i, v := range taxRates </span><span class="cov8" title="1">{
                tVal := 0.0
                if v.ID == taxRates[rIndex].ID </span><span class="cov8" title="1">{
                        tVal = taxFund
                }</span>
                <span class="cov8" title="1">if i+1 != len(taxRates) </span><span class="cov8" title="1">{
                        tFormat := p.Sprintf("%v-%v", number.Decimal(v.LowerBoundIncome), number.Decimal(taxRates[i+1].LowerBoundIncome-1))

                        taxLevels = append(taxLevels, TaxLevelInfo{
                                Tax:   tVal,
                                Level: tFormat,
                        })

                }</span> else<span class="cov8" title="1"> {
                        lastT := p.Sprintf("%v ขึ้นไป", number.Decimal(v.LowerBoundIncome))

                        taxLevels = append(taxLevels, TaxLevelInfo{
                                Tax:   tVal,
                                Level: lastT,
                        })

                }</span>
        }
        <span class="cov8" title="1">return taxLevels</span>
}

func refundTax(taxFund float64) (float64, float64) <span class="cov8" title="1">{
        taxRefund := 0.0

        if math.Signbit(taxFund) </span><span class="cov8" title="1">{
                taxRefund = math.Abs(taxFund)
                taxFund = 0.0
        }</span>
        <span class="cov8" title="1">return taxRefund, taxFund</span>
}

func taxRateIndex(taxRates []TaxRate, income float64) int <span class="cov8" title="1">{

        foundKey := slices.IndexFunc(taxRates, func(t TaxRate) bool </span><span class="cov8" title="1">{
                return income &lt;= t.LowerBoundIncome
        }</span>)

        <span class="cov8" title="1">rIndex := foundKey

        if foundKey &gt; 0 </span><span class="cov8" title="1">{
                rIndex = foundKey - 1
        }</span> else<span class="cov8" title="1"> {
                rIndex = 0
        }</span>
        <span class="cov8" title="1">return rIndex</span>
}

func readCSVRecords(fileUploaded io.Reader) ([][]string, error) <span class="cov8" title="1">{
        read := csv.NewReader(fileUploaded)

        recs, err := read.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return recs, nil</span>
}

func parseFloatValue(v []string) (float64, float64, float64, error) <span class="cov8" title="1">{
        totalIncome, err := praseFloat(v[0])
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, 0, errors.New("total income can not be string or empty")
        }</span>

        <span class="cov8" title="1">wht, err := praseFloat(v[1])
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, 0, errors.New("tax with holding (twh) can not be string or empty")
        }</span>

        <span class="cov8" title="1">amount, err := praseFloat(v[2])
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, 0, errors.New("donation can not be string or empty")
        }</span>

        <span class="cov8" title="1">return totalIncome, wht, amount, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
